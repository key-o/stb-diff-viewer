/**
 * Node.jsÁí∞Â¢É„Åß„ÅÆ„ÉÜ„Çπ„ÉàÂÆüË°å„Çπ„ÇØ„É™„Éó„Éà
 * STB Diff Viewer„ÅÆÂü∫Êú¨Ê©üËÉΩ„Çí„ÉÜ„Çπ„Éà„Åó„Å¶ÂÆüÈöõ„ÅÆÁµêÊûú„ÇíÂá∫Âäõ
 */

console.log('üß™ ======================================');
console.log('   STB Diff Viewer Test Execution');
console.log('   Environment: Node.js');
console.log('üß™ ======================================\n');

// „ÉÜ„Çπ„ÉàÁµêÊûú‰øùÂ≠òÁî®
const testResults = [];

/**
 * „ÉÜ„Çπ„ÉàÂÆüË°åÈñ¢Êï∞
 */
function runTest(name, testFunction) {
  const startTime = Date.now();
  let result;
  
  try {
    result = testFunction();
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    testResults.push({
      name,
      passed: true,
      duration,
      result: result || 'OK'
    });
    
    console.log(`‚úÖ ${name} - PASSED (${duration}ms)`);
    if (result && typeof result === 'object') {
      console.log(`   Details:`, result);
    }
    
  } catch (error) {
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    testResults.push({
      name,
      passed: false,
      duration,
      error: error.message
    });
    
    console.log(`‚ùå ${name} - FAILED (${duration}ms)`);
    console.log(`   Error: ${error.message}`);
  }
}

/**
 * Âü∫Êú¨ÁöÑ„Å™JavaScriptÊ©üËÉΩ„ÉÜ„Çπ„Éà
 */
function testBasicJavaScriptFeatures() {
  // ES6Ê©üËÉΩ„ÉÜ„Çπ„Éà
  const testArray = [1, 2, 3, 4, 5];
  const doubled = testArray.map(x => x * 2);
  const filtered = testArray.filter(x => x > 2);
  
  // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂàÜÂâ≤‰ª£ÂÖ•
  const obj = { a: 1, b: 2, c: 3 };
  const { a, b } = obj;
  
  // „ÉÜ„É≥„Éó„É¨„Éº„Éà„É™„ÉÜ„É©„É´
  const template = `Test: ${a + b}`;
  
  // Promise
  const promise = Promise.resolve('success');
  
  return {
    mapWorking: doubled.join(',') === '2,4,6,8,10',
    filterWorking: filtered.length === 3,
    destructuringWorking: a === 1 && b === 2,
    templateWorking: template === 'Test: 3',
    promiseWorking: promise instanceof Promise
  };
}

/**
 * „Éá„Éº„ÇøÊßãÈÄ†„Éª„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÉÜ„Çπ„Éà
 */
function testDataStructures() {
  // Map
  const testMap = new Map();
  testMap.set('key1', 'value1');
  testMap.set('key2', 'value2');
  
  // Set
  const testSet = new Set([1, 2, 3, 2, 1]);
  
  // Array methods
  const numbers = [1, 2, 3, 4, 5];
  const sum = numbers.reduce((acc, curr) => acc + curr, 0);
  
  return {
    mapSize: testMap.size,
    setValue: testSet.size,
    arraySum: sum,
    mapGetCorrect: testMap.get('key1') === 'value1',
    setUniqueValues: testSet.size === 3
  };
}

/**
 * STBÈñ¢ÈÄ£„Éá„Éº„ÇøÊßãÈÄ†„ÉÜ„Çπ„Éà
 */
function testStbDataStructures() {
  // STBË¶ÅÁ¥†„Çø„Ç§„Éó„ÅÆÂÆöÁæ©
  const ELEMENT_TYPES = {
    NODE: 'Node',
    COLUMN: 'Column',
    GIRDER: 'Girder',
    BEAM: 'Beam',
    BRACE: 'Brace',
    SLAB: 'Slab',
    WALL: 'Wall'
  };
  
  // Ê®°Êì¨Ë¶ÅÁ¥†„Éá„Éº„Çø
  const mockElements = [
    { id: 'N1', type: 'Node', x: 0, y: 0, z: 0 },
    { id: 'C1', type: 'Column', section: 'RC400x400' },
    { id: 'G1', type: 'Girder', section: 'H400x200x8x13' },
    { id: 'B1', type: 'Beam', section: 'RC300x500' }
  ];
  
  // Ë¶ÅÁ¥†Ê§úÁ¥¢„ÉÜ„Çπ„Éà
  const findElement = (elements, id) => elements.find(el => el.id === id);
  const foundGirder = findElement(mockElements, 'G1');
  const foundColumn = findElement(mockElements, 'C1');
  
  // Ë¶ÅÁ¥†ÂàÜÈ°û„ÉÜ„Çπ„Éà
  const nodeElements = mockElements.filter(el => el.type === ELEMENT_TYPES.NODE);
  const structuralElements = mockElements.filter(el => 
    [ELEMENT_TYPES.COLUMN, ELEMENT_TYPES.GIRDER, ELEMENT_TYPES.BEAM].includes(el.type)
  );
  
  // Ë¶ÅÁ¥†„Çø„Ç§„ÉóÂ§âÊèõ„ÉÜ„Çπ„Éà
  const elementTypeToStbName = (type) => type === 'Node' ? 'StbNode' : `Stb${type}`;
  const nodeTagName = elementTypeToStbName('Node');
  const girderTagName = elementTypeToStbName('Girder');
  
  return {
    elementTypesCount: Object.keys(ELEMENT_TYPES).length,
    mockElementsCount: mockElements.length,
    girderFound: foundGirder && foundGirder.type === 'Girder',
    columnFound: foundColumn && foundColumn.section === 'RC400x400',
    nodeCount: nodeElements.length,
    structuralCount: structuralElements.length,
    tagNameConversion: nodeTagName === 'StbNode' && girderTagName === 'StbGirder'
  };
}

/**
 * „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÉÜ„Çπ„Éà
 */
function testErrorHandling() {
  const errors = [];
  
  // Ê®ôÊ∫ñ„Ç®„É©„ÉºÂá¶ÁêÜ
  try {
    throw new Error('Test standard error');
  } catch (error) {
    errors.push({
      type: 'standard',
      message: error.message,
      caught: true
    });
  }
  
  // „Ç´„Çπ„Çø„É†„Ç®„É©„Éº„ÇØ„É©„Çπ
  class StandardError extends Error {
    constructor(message, code, module, operation) {
      super(message);
      this.name = 'StandardError';
      this.code = code;
      this.module = module;
      this.operation = operation;
    }
    
    getUserMessage() {
      const messages = {
        'FILE_LOAD_ERROR': '„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        'XML_PARSE_ERROR': 'STB„Éï„Ç°„Ç§„É´„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
      };
      return messages[this.code] || '‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
    }
  }
  
  try {
    throw new StandardError('Test custom error', 'FILE_LOAD_ERROR', 'ModelLoader', 'loadFile');
  } catch (error) {
    errors.push({
      type: 'custom',
      name: error.name,
      code: error.code,
      userMessage: error.getUserMessage(),
      caught: true
    });
  }
  
  return {
    errorsHandled: errors.length,
    standardErrorCaught: errors[0].caught,
    customErrorWorking: errors[1].name === 'StandardError',
    userMessageGenerated: errors[1].userMessage === '„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
  };
}

/**
 * „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
 */
function testPerformance() {
  // ÈÖçÂàóÂá¶ÁêÜÊÄßËÉΩ
  const startArray = Date.now();
  const largeArray = Array.from({ length: 10000 }, (_, i) => i);
  const processed = largeArray
    .filter(x => x % 2 === 0)
    .map(x => x * 2)
    .reduce((sum, x) => sum + x, 0);
  const arrayTime = Date.now() - startArray;
  
  // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂá¶ÁêÜÊÄßËÉΩÔºàSTB„Éá„Éº„Çø„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
  const startObject = Date.now();
  const elements = Array.from({ length: 1000 }, (_, i) => ({
    id: `element_${i}`,
    type: ['Node', 'Column', 'Girder', 'Beam'][i % 4],
    x: Math.random() * 10000,
    y: Math.random() * 10000,
    z: Math.random() * 5000
  }));
  
  // Ë¶ÅÁ¥†„ÅÆÂàÜÈ°ûÂá¶ÁêÜ
  const grouped = elements.reduce((acc, el) => {
    acc[el.type] = acc[el.type] || [];
    acc[el.type].push(el);
    return acc;
  }, {});
  
  // Â∫ßÊ®ô„Å´„Çà„ÇãÊ§úÁ¥¢Âá¶ÁêÜ
  const nearOrigin = elements.filter(el => 
    Math.sqrt(el.x * el.x + el.y * el.y + el.z * el.z) < 1000
  );
  
  const objectTime = Date.now() - startObject;
  
  // ÊñáÂ≠óÂàóÂá¶ÁêÜÊÄßËÉΩÔºàXMLÁîüÊàê„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
  const startString = Date.now();
  let xmlContent = '<?xml version="1.0" encoding="UTF-8"?>\n<StbModel>\n';
  for (let i = 0; i < 1000; i++) {
    xmlContent += `  <StbNode id="N${i}" X="${i * 100}" Y="${i * 50}" Z="0"/>\n`;
  }
  xmlContent += '</StbModel>';
  const stringTime = Date.now() - startString;
  
  return {
    arrayProcessingTime: arrayTime,
    objectProcessingTime: objectTime,
    stringProcessingTime: stringTime,
    arrayResultCorrect: processed > 0,
    objectGroupingCount: Object.keys(grouped).length,
    nearOriginCount: nearOrigin.length,
    xmlGenerated: xmlContent.includes('<StbNode') && xmlContent.includes('</StbModel>'),
    performanceAcceptable: arrayTime < 100 && objectTime < 50 && stringTime < 100
  };
}

/**
 * XML„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà
 */
function testXmlSimulation() {
  // Ê®°Êì¨STB XML„Éá„Éº„Çø
  const mockStbXml = `<?xml version="1.0" encoding="UTF-8"?>
<ST_BRIDGE xmlns="https://www.building-smart.or.jp/dl" version="2.0.2">
  <StbModel>
    <StbNodes>
      <StbNode id="N1" X="0" Y="0" Z="0"/>
      <StbNode id="N2" X="5000" Y="0" Z="0"/>
      <StbNode id="N3" X="5000" Y="8000" Z="0"/>
      <StbNode id="N4" X="0" Y="8000" Z="0"/>
    </StbNodes>
    <StbMembers>
      <StbColumns>
        <StbColumn id="C1" id_node_bottom="N1" id_node_top="N5" id_section="SC1"/>
        <StbColumn id="C2" id_node_bottom="N2" id_node_top="N6" id_section="SC1"/>
      </StbColumns>
      <StbGirders>
        <StbGirder id="G1" id_node_start="N5" id_node_end="N6" id_section="SG1"/>
        <StbGirder id="G2" id_node_start="N6" id_node_end="N7" id_section="SG1"/>
      </StbGirders>
    </StbMembers>
    <StbSections>
      <StbSecColumn id="SC1" name="C-400x400" kind="RC"/>
      <StbSecGirder id="SG1" name="G-400x700" kind="RC"/>
    </StbSections>
  </StbModel>
</ST_BRIDGE>`;

  // Á∞°ÊòìXMLËß£ÊûêÔºàÊ≠£Ë¶èË°®Áèæ„Éô„Éº„ÇπÔºâ
  const extractElements = (xml, tagName) => {
    const pattern = new RegExp(`<${tagName}[^>]*>`, 'g');
    const matches = xml.match(pattern) || [];
    return matches.map(match => {
      const idMatch = match.match(/id="([^"]*)"/);
      const result = { raw: match };
      if (idMatch) result.id = idMatch[1];
      
      // Â±ûÊÄßÊäΩÂá∫
      const attrPattern = /(\w+)="([^"]*)"/g;
      let attrMatch;
      result.attributes = {};
      while ((attrMatch = attrPattern.exec(match)) !== null) {
        result.attributes[attrMatch[1]] = attrMatch[2];
      }
      
      return result;
    });
  };
  
  const nodes = extractElements(mockStbXml, 'StbNode');
  const columns = extractElements(mockStbXml, 'StbColumn');
  const girders = extractElements(mockStbXml, 'StbGirder');
  const sections = extractElements(mockStbXml, 'StbSecColumn|StbSecGirder');
  
  // „Éá„Éº„ÇøÊßãÈÄ†Ê§úË®º
  const hasValidNamespace = mockStbXml.includes('xmlns="https://www.building-smart.or.jp/dl"');
  const hasValidVersion = mockStbXml.includes('version="2.0.2"');
  const hasRequiredStructure = mockStbXml.includes('<StbModel>') && 
                              mockStbXml.includes('<StbNodes>') &&
                              mockStbXml.includes('<StbMembers>');
  
  // Ë¶ÅÁ¥†Èñ¢‰øÇ„ÅÆÊ§úË®º
  const nodeIds = nodes.map(n => n.id);
  const girderG1 = girders.find(g => g.id === 'G1');
  const hasValidReferences = girderG1 && 
                            girderG1.attributes.id_node_start &&
                            girderG1.attributes.id_node_end;
  
  return {
    xmlLength: mockStbXml.length,
    nodeCount: nodes.length,
    columnCount: columns.length,
    girderCount: girders.length,
    validNamespace: hasValidNamespace,
    validVersion: hasValidVersion,
    validStructure: hasRequiredStructure,
    validReferences: hasValidReferences,
    sampleNodeIds: nodeIds.slice(0, 3),
    sampleGirderAttributes: girderG1 ? Object.keys(girderG1.attributes) : []
  };
}

/**
 * „Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„Ç¢„ÇØ„Çª„Çπ„ÉÜ„Çπ„Éà
 */
function testFileSystemAccess() {
  const fs = require('fs');
  const path = require('path');
  
  // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´„ÅÆÂ≠òÂú®Á¢∫Ë™ç
  const projectFiles = [
    'index.html',
    'js/main.js',
    'js/viewer/index.js',
    'js/parser/stbXmlParser.js',
    'js/test/comprehensiveTestSuite.js',
    'js/utils/codeStandards.js',
    '.eslintrc.js'
  ];
  
  const fileChecks = projectFiles.map(filePath => {
    try {
      const stats = fs.statSync(filePath);
      return {
        path: filePath,
        exists: true,
        size: stats.size,
        isFile: stats.isFile()
      };
    } catch (error) {
      return {
        path: filePath,
        exists: false,
        error: error.code
      };
    }
  });
  
  // „Çµ„É≥„Éó„É´„Éï„Ç°„Ç§„É´„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÁ¢∫Ë™ç
  let sampleDirCheck = { exists: false };
  try {
    const sampleStats = fs.statSync('sampleStb');
    const sampleFiles = fs.readdirSync('sampleStb');
    sampleDirCheck = {
      exists: true,
      isDirectory: sampleStats.isDirectory(),
      fileCount: sampleFiles.length,
      sampleFiles: sampleFiles.filter(f => f.endsWith('.stb')).slice(0, 3)
    };
  } catch (error) {
    sampleDirCheck.error = error.code;
  }
  
  const existingFiles = fileChecks.filter(f => f.exists);
  const missingFiles = fileChecks.filter(f => !f.exists);
  
  return {
    totalFilesChecked: projectFiles.length,
    existingFiles: existingFiles.length,
    missingFiles: missingFiles.length,
    sampleDirExists: sampleDirCheck.exists,
    sampleFileCount: sampleDirCheck.fileCount || 0,
    allCoreFilesExist: existingFiles.length >= 5,
    missingFilesList: missingFiles.map(f => f.path)
  };
}

/**
 * „É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞
 */
function runAllTests() {
  const overallStartTime = Date.now();
  
  // ÂêÑ„ÉÜ„Çπ„Éà„ÇíÂÆüË°å
  runTest('1. Basic JavaScript Features', testBasicJavaScriptFeatures);
  runTest('2. Data Structures', testDataStructures);
  runTest('3. STB Data Structures', testStbDataStructures);
  runTest('4. Error Handling', testErrorHandling);
  runTest('5. Performance Test', testPerformance);
  runTest('6. XML Simulation', testXmlSimulation);
  runTest('7. File System Access', testFileSystemAccess);
  
  const overallEndTime = Date.now();
  const totalDuration = overallEndTime - overallStartTime;
  
  // ÁµêÊûú„Çµ„Éû„É™„Éº
  console.log('\nüìä ======================================');
  console.log('   TEST RESULTS SUMMARY');
  console.log('üìä ======================================');
  
  const passed = testResults.filter(r => r.passed).length;
  const failed = testResults.filter(r => !r.passed).length;
  const total = testResults.length;
  const successRate = ((passed / total) * 100).toFixed(1);
  
  console.log(`üìã Total Tests: ${total}`);
  console.log(`‚úÖ Passed: ${passed}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üéØ Success Rate: ${successRate}%`);
  console.log(`‚è±Ô∏è  Total Duration: ${totalDuration}ms`);
  console.log(`üíæ Average per test: ${(totalDuration / total).toFixed(1)}ms`);
  
  if (failed > 0) {
    console.log('\n‚ùå FAILED TESTS:');
    testResults.filter(r => !r.passed).forEach(test => {
      console.log(`   - ${test.name}: ${test.error}`);
    });
  }
  
  // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁµ±Ë®à
  const durations = testResults.map(r => r.duration);
  const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
  const maxDuration = Math.max(...durations);
  const minDuration = Math.min(...durations);
  
  console.log('\n‚ö° PERFORMANCE STATISTICS:');
  console.log(`   Average: ${avgDuration.toFixed(1)}ms`);
  console.log(`   Maximum: ${maxDuration}ms`);
  console.log(`   Minimum: ${minDuration}ms`);
  
  // ÊàêÂäü„Åó„Åü„ÉÜ„Çπ„Éà„ÅÆË©≥Á¥∞
  console.log('\n‚úÖ SUCCESSFUL TESTS:');
  testResults.filter(r => r.passed).forEach(test => {
    console.log(`   ‚úì ${test.name} (${test.duration}ms)`);
  });
  
  console.log('\nüéâ TEST EXECUTION COMPLETED!\n');
  
  return {
    summary: {
      total,
      passed,
      failed,
      successRate: parseFloat(successRate),
      duration: totalDuration,
      averageDuration: avgDuration,
      maxDuration,
      minDuration
    },
    details: testResults
  };
}

// ÂÆüË°å
runAllTests();
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>XML Viewer – In‑Editor XPath Generator (relative fix)</title>
    <style>
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        font-family: sans-serif;
      }
      #sidebar {
        width: 38%;
        border-right: 1px solid #666;
        display: flex;
        flex-direction: column;
      }
      #sidebar header {
        padding: 4px;
        background: #222;
        color: #eee;
        font-weight: bold;
      }
      #sidebar input[type="text"] {
        width: 100%;
        box-sizing: border-box;
        background: #333;
        color: #d4d4d4;
        padding: 4px;
        border: none;
        font-size: 0.9em;
      }
      #sidebar input[type="text"]:focus {
        outline: 2px solid #555;
      }
      #sidebar button {
        margin: 4px 0;
        padding: 4px 8px;
      }
      #main {
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      #editor {
        flex: 1;
        border: 1px solid #666;
      }
      .info-label {
        background: #222;
        color: #eee;
        font-size: 0.8em;
        padding: 2px 4px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"></script>
    <script>
      require.config({
        paths: {
          vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs",
        },
      });
      let editor, xmlModel;
      let lastStack = [],
        lastAttr = null;
      let baseStack = null,
        baseAttr = null;

      require(["vs/editor/editor.main"], () => {
        editor = monaco.editor.create(document.getElementById("editor"), {
          language: "xml",
          theme: "vs-dark",
          automaticLayout: true,
          folding: true,
          scrollBeyondLastLine: false,
        });
        xmlModel = editor.getModel();
        editor.onDidChangeCursorPosition(updateXPathFromCursor);
      });

      function loadXml(f) {
        const r = new FileReader();
        r.onload = (e) => {
          editor.setValue(e.target.result);
          setTimeout(updateXPathFromCursor, 50);
        };
        r.readAsText(f, "utf-8");
      }

      function updateXPathFromCursor() {
        const pos = editor.getPosition();
        if (!pos) return;
        const offset = xmlModel.getOffsetAt(pos);
        const info = parseXPath(xmlModel.getValue(), offset);
        if (!info) return;
        lastStack = info.stack;
        lastAttr = info.attr;
        document.getElementById("xpathCurrent").value = abs(
          lastStack,
          lastAttr
        );
        document.getElementById("relXPath").value = baseStack ? rel() : "";
      }

      const abs = (st, a) => "/" + st.join("/") + (a ? "/@" + a : "");

      function rel() {
        if (baseAttr) return "(基準が属性のため相対不可)";
        let i = 0;
        while (
          i < baseStack.length &&
          i < lastStack.length &&
          baseStack[i] === lastStack[i]
        )
          i++;
        const up = "../".repeat(baseStack.length - i).replace(/\/$/, "");
        const down = lastStack.slice(i).join("/");
        let p = (up && (down ? up + down : up)) || down || ".";
        if (lastAttr) p += "/@" + lastAttr;
        return p;
      }

      function parseXPath(txt, off) {
        const tagRe = /<\/(?:[^>]+)>|<([^!?][^>]*?)>/g;
        const stack = [];
        let m,
          lastOpen = null;
        while ((m = tagRe.exec(txt))) {
          const idx = m.index;
          if (idx > off) break; // **早期判定で余分プッシュ防止**
          const tag = m[0];
          if (tag.startsWith("</")) {
            stack.pop();
            continue;
          }
          const selfClose = tag.endsWith("/>");
          const name = m[1].split(/\s+/)[0];
          stack.push(name);
          lastOpen = { start: idx, end: tagRe.lastIndex, code: tag, selfClose };
          if (selfClose && lastOpen.end <= off) {
            stack.pop();
          }
        }
        if (!stack.length) return null;
        let attr = null;
        if (lastOpen && off >= lastOpen.start && off <= lastOpen.end) {
          const rel = off - lastOpen.start;
          const attrRe = /([\w:\-]+)\s*=\s*("[^"]*"|'[^']*')/g;
          let a;
          while ((a = attrRe.exec(lastOpen.code))) {
            const s = a.index,
              e = s + a[0].length;
            if (rel >= s && rel <= e) {
              attr = a[1];
              break;
            }
          }
        }
        return { stack: [...stack], attr };
      }

      function setBase() {
        if (!lastStack.length) return;
        baseStack = [...lastStack];
        baseAttr = lastAttr;
        document.getElementById("baseXPath").value = abs(baseStack, baseAttr);
        updateXPathFromCursor();
      }
      const copyField = (id) => {
        const el = document.getElementById(id);
        el.select();
        document.execCommand("copy");
      };
    </script>
  </head>
  <body>
    <div id="sidebar">
      <label class="info-label">ファイル読み込み</label>
      <input type="file" accept=".stb" oninput="loadXml(this.files[0])" />

      <header>XPath (カーソル位置)</header>
      <input
        id="xpathCurrent"
        readonly
        placeholder="カーソルを XML 要素/属性上へ置くと表示"
        onclick="copyField('xpathCurrent')"
      />
      <button onclick="copyField('xpathCurrent')">Copy Abs</button>
      <button onclick="setBase()">Set as Base</button>
      <label class="info-label">Base XPath</label>
      <input id="baseXPath" readonly onclick="copyField('baseXPath')" />
      <label class="info-label">Relative to Base</label>
      <input id="relXPath" readonly onclick="copyField('relXPath')" />
    </div>
    <div id="main"><div id="editor"></div></div>
  </body>
</html>
